import random
import math
import csv

def csv_into_list():  #Met le fichier sous forme de liste
  data = []
  count = 0
  with open("winequalityred.csv",'r') as file:
    reader = csv.reader(file, delimiter =';')
    for row in reader:
      if count == 0:
        count += 1 #On passe la 1Ã¨re ligne
      else:
        data.append(row)
  return data
  

def str_into_float(data,col):
  for row in data:
    row[col] = float(row[col])

"""
Pas utile pour le moment, va ralentir l'execution pour rien.
data = csv_into_list()
for i in range(len(data[0])-1):
  str_into_float(data,i)
"""

"""
Test
for row in data:
  print(row[0],type(row[0]))
  break
"""


class NeuralNetwork():
  def __init__(self,n_input,n_hidden,n_output):
    self.n_input = n_input
    self.n_hidden = n_hidden
    self.n_output = n_output

  def activation(self):
    network = []
    h_layer = [{'weights' : [random.random() for i in range(self.n_input+1)]} for j in range(self.n_hidden)]
    o_layer = [{'weights' : [random.random() for i in range(self.n_hidden+1)]} for j in range(self.n_output)]
    network.append(h_layer)
    network.append(o_layer)
    return network

""""
  def sigmoid(self):
		a = (1 / (1 + exp(-x)))
		return a
        
  def sigmoid_derivative(self,x):
    b = self.sigmoid(x) * (1 - self.sigmoid(x))
		return b

  def train(self, training_set_inputs, training_set_outputs, number_of_training_iterations):
        for iteration in range(number_of_training_iterations):
            output = self.think(training_set_inputs)
            error = training_set_outputs - output
            adjustment = dot(training_set_inputs.T, error * self.__sigmoid_derivative(output))
		   	self.synaptic_weights += adjustment
 
  def think(self, inputs):
     return self.__sigmoid(dot(inputs, self.synaptic_weights))
"""
qqch = NeuralNetwork(11,3,1)
#print(qqch.activation())
